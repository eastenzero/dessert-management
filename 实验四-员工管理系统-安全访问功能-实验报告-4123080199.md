# 实验四：员工管理系统-安全访问功能

## 一、实验目的

- **掌握基于 Token 的前后端分离安全访问机制**  
  能够在后端签发、校验 Token，并通过拦截器限制只有登录用户才能访问员工管理接口。

- **掌握用户注册与密码加密存储的方法**  
  使用 BCrypt 对用户密码进行不可逆加密，避免明文存储。

- **理解前后端在认证过程中的协作方式**  
  包括登录时获取 Token、前端在后续请求中自动携带 Token、退出登录时清理 Token 等流程。

---

## 二、实验环境

- **后端**：Spring Boot 3.0.2，MyBatis，PageHelper
- **前端**：Vue 3，Element Plus，axios
- **数据库**：MySQL（`desserts` 库，含 `t_user` 表）
- **JDK**：JDK 17

---

## 三、实验内容概述

本实验在“员工管理系统”基础上，完成以下安全相关功能：

1. **使用 Token 实现安全访问**
   - 登录成功后，后端为用户签发 Token；
   - 前端保存 Token，并在访问员工管理接口 `/employee/**` 时通过请求头携带 Token；
   - 后端使用拦截器统一校验 Token，未登录或 Token 无效的请求返回 401 状态码。

2. **实现用户注册功能，密码加密存储**
   - 新增注册接口 `/auth/register`；
   - 使用 BCrypt 算法对用户密码进行加密后再写入 `t_user` 表；
   - 前端提供注册页面，让新用户可以自行注册。

3. **登录 / 退出流程**
   - 登录接口 `/auth/login`：验证用户名 + 明文密码是否与数据库中加密密码匹配；
   - 登录成功返回包含 Token 的响应；
   - 退出接口 `/auth/logout`：清理服务端保存的 Token 信息，前端同时删除本地 Token。

---

## 四、Token 安全访问设计与实现

### 4.1 后端 Token 设计

1. **Token 生成与保存**
   - 在后端新增 `TokenService` 组件：
     - 使用 `UUID` 生成随机字符串作为 Token；
     - 使用内存中的 `ConcurrentHashMap` 维护 Token 与用户 ID 的映射关系；
     - 提供 `createToken(userId)`、`getUserIdByToken(token)`、`removeToken(token)` 等方法。

2. **登录时签发 Token**
   - 在 `UserService` 的登录逻辑中：
     - 先根据用户名查询 `t_user` 表中的用户信息；
     - 使用 `BCryptPasswordEncoder.matches` 校验明文密码；
     - 校验通过后调用 `TokenService.createToken(userId)` 生成 Token，并返回给前端。

3. **退出登录时失效 Token**
   - 在 `AuthController.logout` 中，从请求头中读取 `Authorization: Bearer xxx`，截取出 Token，调用 `TokenService.removeToken(token)` 将其从内存中移除。

### 4.2 登录拦截与访问控制

1. **登录拦截器 `LoginInterceptor`**
   - 实现 `HandlerInterceptor` 接口，在 `preHandle` 方法中：
     - 对 `OPTIONS` 请求直接放行，便于跨域预检；
     - 从请求头中读取 `Authorization`，检查是否以 `Bearer ` 开头；
     - 调用 `TokenService.getUserIdByToken(token)`，判断 Token 是否有效；
     - 无 Token 或无效 Token 时，返回 HTTP 401 和 JSON 提示信息，阻止后续处理；
     - 校验通过时，将 `loginUserId` 存入 `request` 属性，为后续业务使用预留扩展点。

2. **在 `MvcConfig` 中注册拦截器**
   - 在已有的 `MvcConfig` 中，除了保留静态资源映射（`/photo/**`），新增 `addInterceptors`：
     - 将 `LoginInterceptor` 注册到 Spring MVC；
     - 设置拦截路径为 `/employee/**`；
     - 这样，所有员工管理相关接口都必须携带合法 Token 才能访问，其它如分类、部门、甜点接口保持原有开放状态。

3. **未登录访问的效果**
   - 当前端未登录、`localStorage` 中无 Token 时访问员工管理接口：
     - 请求被拦截器拒绝，返回 401 状态码；
     - 响应体中包含 `{ "code": 401, "msg": "未登录或Token缺失" }` 或 `"Token无效或已过期"` 的提示。

---

## 五、用户注册与密码加密

### 5.1 `t_user` 表与用户实体

1. **数据库表结构**（在 `数据库.SQL` 中已给出）：
   - `t_user(id, username, password, active)`
     - `username`：登录用户名；
     - `password`：登录密码，经 BCrypt 算法加密后存储；
     - `active`：用户是否可用（1 可用，0 不可用）。

2. **后端用户实体与 Mapper**
   - 新增 `User` 实体类，包含 `id, username, password, active` 字段；
   - 新增 `UserMapper` 接口：
     - `findByUsername(String username)`：根据用户名查询用户；
     - `insert(User user)`：插入新用户记录。

### 5.2 密码加密实现

1. **引入加密依赖**
   - 在后端 `pom.xml` 中新增依赖：
     - `spring-security-crypto`，用于提供 `BCryptPasswordEncoder`。

2. **在 `UserService` 中使用 BCrypt**
   - 定义 `BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();`；
   - 注册时：
     - 判断用户名是否已存在（防止重复注册）；
     - 使用 `passwordEncoder.encode(rawPassword)` 对明文密码进行加密；
     - 将加密后的密码写入 `t_user.password` 字段；
   - 登录时：
     - 读取数据库中加密后的密码；
     - 使用 `passwordEncoder.matches(rawPassword, encodedPassword)` 验证明文与密文是否匹配。

3. **注册接口 `/auth/register`**
   - 控制器 `AuthController.register(User user)`：
     - 调用 `UserService.register(user)`；
     - 如果用户名已存在，返回 `AjaxResult.error(400, "用户名已存在")`；
     - 注册成功时返回 `AjaxResult.success("注册成功")`。

---

## 六、前端注册与登录流程

### 6.1 注册页面 `Register.vue`

1. **表单结构**
   - 字段：用户名、密码、确认密码；
   - 使用 Element Plus 的 `el-form`、`el-input`、`el-button` 组件实现；
   - 设置必填校验和“二次密码一致性”校验规则。

2. **调用注册接口**
   - 通过 `AuthService.register(payload)` 调用 `/auth/register`；
   - 成功时提示“注册成功，密码已在服务器端加密保存”；
   - 失败时根据返回的 `msg` 提示错误原因（如用户名已存在）。

### 6.2 登录对话框与 Token 保存

1. **登录对话框实现**
   - 在 `App.vue` 顶部区域，利用 Element Plus 的 `el-dialog` 增加“用户登录”弹窗；
   - 表单字段：用户名、密码；
   - 点击“登录”按钮后，通过 `AuthService.login` 调用 `/auth/login` 接口。

2. **前端保存 Token**
   - 登录成功时，从响应体中读取 `data.token`：
     - 使用 `localStorage.setItem('token', token)` 将 Token 保存在浏览器本地；
     - 在页面上显示当前登录用户名；
     - 关闭登录对话框并提示“登录成功”。

3. **请求拦截器自动携带 Token**
   - 在 `src/utils/request.js` 中，为 axios 实例增加请求拦截器：
     - 每次请求前，从 `localStorage` 中读取 Token；
     - 若 Token 存在，则在请求头中加入 `Authorization: Bearer <token>`；
     - 这样所有使用该 axios 实例的接口调用都会自动带上 Token，无需每个 API 单独设置。

4. **退出登录**
   - 顶部“退出”按钮调用 `AuthService.logout()`；
   - 无论后端成功与否，前端都会清空 `localStorage` 中的 Token，并重置登录状态；
   - 页面上显示“已退出登录”的提示。

---

## 七、实验效果说明

1. **未登录访问员工管理接口**
   - 直接在浏览器访问“员工管理”页面或触发员工列表查询时，若未登录：
     - axios 请求中不携带 `Authorization` 头；
     - 后端拦截器返回 401 和错误提示，前端可以在控制台或网络面板中看到相应响应。

2. **注册新用户并登录后访问**
   - 在“用户注册”页面注册新用户（例如用户名 `alice`）；
   - 返回信息提示“注册成功，密码已在服务器端加密保存”；
   - 通过顶部“登录”按钮输入该用户名和密码登录成功；
   - 登录后再次进入“员工管理”页面，接口请求中会自动带上 Token，后端校验通过，员工数据正常返回。

3. **密码加密存储验证**
   - 在数据库 `t_user` 表中查看新注册用户的密码字段：
     - 可以看到密码是以 `$2a$` 或 `$2b$` 开头的一长串字符串，说明已使用 BCrypt 加密；
     - 原始明文密码无法直接从数据库中反推出，提高了安全性。

---

## 八、实验总结

- 本实验通过在原有员工管理系统中引入 Token 验证机制，实现了对 `/employee/**` 接口的访问控制，只有登录用户才能进行员工数据的查询和维护。
- 通过引入 `spring-security-crypto` 并使用 `BCryptPasswordEncoder`，实现了用户密码的加密存储，避免了明文密码带来的安全风险。
- 使用前端 axios 请求拦截器统一添加 `Authorization` 请求头，简化了前端与后端的认证交互逻辑，让各业务模块只需关注自身业务即可。
- 通过本次实验，对“用户注册 → 密码加密 → 登录获取 Token → 拦截器校验 → 安全访问业务接口”这一完整认证链路有了更加直观的理解，为后续学习更完整的安全框架（如 Spring Security、JWT 等）打下基础。
